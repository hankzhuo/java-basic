## 面向对象

创建类，实例化对象，符合"单一职责原则"。

```
// 声明对象 
Cat one
// 实例化对象
new Cat();
// 赋值
one = new Cat() 
```
对象实例化的过程：
- 声明对象：声明对象实际是在栈开辟一个空间放变量 one
- 实例化对象：在堆内存中开辟一个空间 `0x0001` 存放对象
- 赋值：把栈地址 `0x0001` 赋值给变量 one


**构造方法**：
- 构造方法与类名相同，且没有返回值
- 只能在对象实例化的时候调用，不能再类内部调用构造方法
- 当没有指定构造方法时，系统会自动添加无参的构造方法
- 当有指定的构造方法，无论是有参、无参的构造方法，都不会自动添加无参的构造方法
- 一个类中可以有多个构造方法



### 封装

特点：
- 只能通过规定的方法访问数据
- 隐藏类的实例细节，方便修改和实现


**封装实现步骤**：
- 修改属性的可见性，设为 `private`，实例访问不到该属性，是类的私有属性
- 创建 `getter/setter` 方法，设为 `public` 用于属性的读写
- 在 `getter/setter` 方法中加入属性控制语句，对属性值合法性进行判断 


**static 关键字**：
- `static` + 属性 => 静态属性、类属性
- `static` + 方法 => 静态方法、类方法
- 可以通过类名方式访问静态成员，也可以通过实例访问
- 静态方法中不能使用 this
- 静态方法中不能直接访问非静态成员，可以访问静态成员
- 不存在静态类
- 不存在方法中的静态局部变量
- 静态成员的生命周期，类加载时产生，销毁时释放，生命周期长
- 静态代码块不管实例化多少次，只会执行一次；构造代码块在每次对象构造的时候调用

 
**导入包方法**：
```
// 加载 obj.animal 包下所有的类
import obj.animal.*;
 
// 加载 obj.animal 包下 Cat 类
import Cat; 

//方法 3：直接加载 Cat 类
Cat myCat = new Cat()
```


### 继承 

- 只能单继承
- 子类可以获取到父类的非 `private` 属性，可以通过 `get/set` 方式
- 子类重写的方法可以覆盖父类中方法
    - 方法名、返回值完全与父类相同
    - 子类中方法的修饰符权限必须大于等于父类修饰符权限（`private` < 默认 < `protected` < `public`）
    - 参数名可以不同 
- 子类属性也可以重写父类中的属性


**访问修饰符：**
- `private`：只允许在本类中访问
- 默认：允许在当前类、同包子类允许，跨包不允许
- `protected`：允许在当前类、子类、同包非子类、跨包非子类不允许
- `public`：允许在任意位置访问

![图片来源网络](../images/02.jpeg)


继承的初始化顺序
- 父类静态成员
- 子类的静态成员
- 父类对象构造
- 子类对象构造


**`super` 关键字**：
- 访问父类成员方法  `super.pint()`
- 访问父类属性 `super.name`
- 访问父类构造方法 `super()`
- `super`不能在静态方法内使用


子类的构造过程中必须调用其父类的构造方法。如果子类的构造方法中没有显示标注，则系统默认调用父类无参构造方法。
使用 super 调用父类指定的构造方法，必须在子类的构造方法的第一行。

Object 类是所有父类的父亲。

**`final` 关键字**：
- 修饰类时：表示该类没有子类，不能被继承
- 修饰方法时：不被子类重写
- 修饰属性时：
    - 类中成员属性：赋值过程：1、定义时候直接初始化  2、构造方法  3、构造代码块
    - 内部局部变量：只要在具体被使用之前赋值即可，一旦赋值不允许被修改


`@Override` 表示在子类重写父类方法的注解，编译时会自动去除。


### 多态

运行时多态：程序运行时动态决定调用哪个方法。
- 向上转型（隐式转型、自动转型）
    - 父类引用指向子类实例，可以调用子类重写父类的方法以及父类派生的方法，无法使用子类独有方法
    - 小类转型为大类
    - 注意：父类中的静态方法无法被子类重写，所以向上转型之后，只能调用父类原有的静态方法
- 向下转型（强制类型转换）
    - 子类引用指向父类对象，必须强制转换，可以调用子类特有的方法

`instanceof` 判断某个对象是否某个类实例，返回 `true / false`。

**abstract 关键字**：
- 在类名前时：抽象类，不允许被实例化。
- 在抽象类中方法前：抽象方法，必须在抽象类中使用，不允许包含方法体，子类中需要重写该方法
- 不允许 `static`、`final`、`private` 关键字一起使用


**接口 interface**：

接口定义了某一批类所需要遵循的规范，接口不关心这些类内部的数据和细节，只规定这些类里面必须提供某些方法。

- 接口中抽象方法可以不写 `abstract` 关键字，修饰符默认 `public`、`abstract`
- 一个类可以使用多个接口，使用逗号隔开
- 接口也可以继承，并且可以继承多个父接口


### 内部类

**成员内部类**
- 内部类在外部使用时，无法直接实例化，需要借助外部类信息才能完成实例化
- 内部类的修饰访问符，可以任意，但是访问范围会受到影响
- 内部类可以直接访问外部类的成员；如果出现重名属性，优先访问内部类定义的
- 可以使用外部类.this.成员方式，访问外部类的同名信息
- 外部类访问内部类信息，需要通过内部类实例，无法直接访问
- 内部类编译后 .class 文件命名：外部类$内部类.class


**静态内部类**：
- 静态内部类中，只能直接访问外部类的静态成员，如果需要调用非静态成员，可以通过对象实例
- 静态内部类对象实例时，可以不依赖于外部类对象
- 可以通过外部类.内部类.静态成员的方式，访问内部类中的静态成员


**方法内部类**：
- 定义在方法内部，作用范围也在方法内
- 和方法内部成员使用规则一样，class 前面不可以添加 public、private、protected、static
- 类中不能包含静态成员
- 类中可以包含 final、abstract 修饰成员


**匿名内部类**：
- 只用到类的一个实例，类在定义后马上用到
- 给类命名并不会导致代码更容易被理解